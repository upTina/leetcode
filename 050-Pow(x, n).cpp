class Solution {
public:
	double myPow(double x, int n) {
		if (x == 0) return 0;
		double res;
		if (n > 0) res = power(x, n);
		else res = power(x, -n);
		return n > 0 ? res : 1 / res;
	}
	double power(double x, int n) {
		if (n == 0) return 1;
		if (n % 2 == 0) return power(x, n / 2)*power(x, n / 2);
		else return x*power(x, n / 2)*power(x, n / 2);
	}
};
/*
这个方法我明明知道，也知道用折半来做，可是，却在用循环处理奇偶数时出了问题。
可这道题明明用递归做就很简单，很好处理。
现在要记住一个真理：循环不行就递归。
总结一下我最近的感悟：
1.节省时间一般就需要辅助内存，辅助内存一般可能就会需要哈希表
2.当不允许使用哈希表的时候，可能我们就需要对给出的变量本身进行调整，即可能我们需要把变量本身当做一个我们的表来处理
3.有时候总觉得用循环来做这个题目可能会做出来，而循环的层数又会随着n而变化时，那你很可能需要递归。循环不行就递归
4.暴力递归不行，就加判定条件再进入递归，那么这可能就变成了回溯法
5.暴力递归如果超时，那就又需要重新回到循环。
6.如果这道题目需要你用递归做，而你用循环做，那么一般内存会不够
  如果这道题目需要你用循环做，而你用递归做，那么一般时间会不够
7.如果题目中间出现先进后出，进进出出的情况，那么多半需要用栈或者队列
*/
